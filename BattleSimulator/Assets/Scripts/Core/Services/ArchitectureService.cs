#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Assertions;
// ReSharper disable UnusedMember.Global

namespace Core.Services
{
    /// <summary>
    /// Architecture entry point. Injects configuration files.
    /// </summary>
    public static class ArchitectureService
    {
#if UNITY_EDITOR || DEVELOPMENT_BUILD
        static readonly List<Type> _usedConfigs = new();
        static int _lastFrameCount;
#endif

        static readonly ScriptableObject[] _configs = Resources.LoadAll<ScriptableObject>("Configs");

        /// <summary>
        /// Starts dependency injection and debug commands initialization.
        /// Tapping delay is used only when the game is build on mobile devices and tells how fast player has to tap to open the debug console.
        /// </summary>
        public static void Inject()
        {
            DependencyInjectionService<ScriptableObject>.Inject(FindConfig);
        }

#region Intercept
        /// <summary>
        /// This method should only be called by autogenerated class called Signals.g.cs.
        /// </summary>
        public static void Intercept(int signalId, string methodName) =>
            SignalDispatch.Intercept(signalId, methodName);

        /// <summary>
        /// This method should only be called by autogenerated class called Signals.g.cs.
        /// </summary>
        public static void Intercept(int signalId, string methodName,
            object arg0) =>
            SignalDispatch.Intercept(signalId, methodName, arg0);

        /// <summary>
        /// This method should only be called by autogenerated class called Signals.g.cs.
        /// </summary>
        public static void Intercept(int signalId, string methodName,
            object arg0, object arg1) =>
            SignalDispatch.Intercept(signalId, methodName, arg0, arg1);

        /// <summary>
        /// This method should only be called by autogenerated class called Signals.g.cs.
        /// </summary>
        public static void Intercept(int signalId, string methodName,
            object arg0, object arg1, object arg2) =>
            SignalDispatch.Intercept(signalId, methodName, arg0, arg1, arg2);

        /// <summary>
        /// This method should only be called by autogenerated class called Signals.g.cs.
        /// </summary>
        public static void Intercept(int signalId, string methodName,
            object arg0, object arg1, object arg2, object arg3) =>
            SignalDispatch.Intercept(signalId, methodName, arg0, arg1, arg2, arg3);

        /// <summary>
        /// This method should only be called by autogenerated class called Signals.g.cs.
        /// </summary>
        public static void Intercept(int signalId, string methodName,
            object arg0, object arg1, object arg2, object arg3, object arg4) =>
            SignalDispatch.Intercept(signalId, methodName, arg0, arg1, arg2, arg3, arg4);

        /// <summary>
        /// This method should only be called by autogenerated class called Signals.g.cs.
        /// </summary>
        public static void Intercept(int signalId, string methodName,
            object arg0, object arg1, object arg2, object arg3, object arg4, object arg5) =>
            SignalDispatch.Intercept(signalId, methodName, arg0, arg1, arg2, arg3, arg4, arg5);

        /// <summary>
        /// This method should only be called by autogenerated class called Signals.g.cs.
        /// </summary>
        public static void Intercept(int signalId, string methodName,
            object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6) =>
            SignalDispatch.Intercept(signalId, methodName, arg0, arg1, arg2, arg3, arg4, arg5, arg6);

        /// <summary>
        /// This method should only be called by autogenerated class called Signals.g.cs.
        /// </summary>
        public static void Intercept(int signalId, string methodName,
            object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7) =>
            SignalDispatch.Intercept(signalId, methodName, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
#endregion

        public static void InvokeInitialization() => DependencyInjectionService<ScriptableObject>.InvokeInitialization();

        /// <summary>
        /// Process and execute all signals sent. Should be called only once per frame.
        /// </summary>
        public static void ExecuteSentSignals()
        {
#if UNITY_EDITOR || DEVELOPMENT_BUILD
            Assert.IsFalse(_lastFrameCount == Time.frameCount, "Signals should be executed once per frame.");
            _lastFrameCount = Time.frameCount;
#endif

            SignalService.ExecuteSentSignals();
        }

        /// <summary>
        /// Returns null if no config was found.
        /// </summary>
        static ScriptableObject? FindConfig(Type type)
        {
#if UNITY_EDITOR || DEVELOPMENT_BUILD
            if (!_usedConfigs.Contains(type))
                _usedConfigs.Add(type);
#endif
            return _configs.FirstOrDefault(c => c.GetType() == type);
        }
    }
}